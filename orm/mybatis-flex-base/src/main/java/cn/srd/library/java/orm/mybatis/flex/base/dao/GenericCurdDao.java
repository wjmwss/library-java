// Copyright (C) 2021-2023 thinkingto.com Ltd. All rights reserved.
// Use of this source code is governed by SRD.
// license that can be found in the LICENSE file.

package cn.srd.library.java.orm.mybatis.flex.base.dao;

import cn.srd.library.java.contract.constant.module.ModuleView;
import cn.srd.library.java.contract.constant.page.PageConstant;
import cn.srd.library.java.contract.constant.text.SuppressWarningConstant;
import cn.srd.library.java.contract.model.throwable.LibraryJavaInternalException;
import cn.srd.library.java.orm.contract.model.base.BO;
import cn.srd.library.java.orm.contract.model.base.PO;
import cn.srd.library.java.orm.contract.model.page.PageParam;
import cn.srd.library.java.orm.contract.model.page.PageResult;
import cn.srd.library.java.orm.mybatis.flex.base.chain.DeleteChainer;
import cn.srd.library.java.orm.mybatis.flex.base.chain.QueryChainer;
import cn.srd.library.java.orm.mybatis.flex.base.chain.UpdateChainer;
import cn.srd.library.java.orm.mybatis.flex.base.converter.PageConverter;
import cn.srd.library.java.orm.mybatis.flex.base.tool.MybatisFlexs;
import cn.srd.library.java.tool.lang.collection.Collections;
import cn.srd.library.java.tool.lang.convert.Converts;
import cn.srd.library.java.tool.lang.functional.Action;
import cn.srd.library.java.tool.lang.object.Nil;
import cn.srd.library.java.tool.lang.reflect.Reflects;
import cn.srd.library.java.tool.lang.text.Strings;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.mybatisflex.core.BaseMapper;
import com.mybatisflex.core.keygen.CustomKeyGenerator;
import com.mybatisflex.core.logicdelete.LogicDeleteManager;
import com.mybatisflex.core.query.QueryWrapper;
import com.mybatisflex.core.row.Db;
import com.mybatisflex.core.service.IService;
import com.mybatisflex.core.util.ClassUtil;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.springframework.transaction.annotation.Transactional;

import java.io.Serializable;
import java.sql.Statement;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;

/**
 * the generic curd dao
 *
 * @param <T> the entity extends {@link PO}
 * @author wjm
 * @since 2023-11-04 00:19
 */
@CanIgnoreReturnValue
public interface GenericCurdDao<T extends PO> {

    @SuppressWarnings(SuppressWarningConstant.UNCHECKED)
    private BaseMapper<T> getBaseMapper() {
        return (BaseMapper<T>) GenericCurdDaoAdapter.getInstance().getBaseMapper(this.getClass());
    }

    /**
     * see <a href="https://mybatis-flex.com/zh/base/batch.html">"the batch operation guide"</a>.
     */
    int GENERATE_FULL_SQL_BATCH_SIZE = 100;

    /**
     * default batch operation size each time
     */
    int DEFAULT_BATCH_SIZE_EACH_TIME = BaseMapper.DEFAULT_BATCH_SIZE;

    default QueryChainer<T> openQuery() {
        return QueryChainer.of(getBaseMapper());
    }

    default UpdateChainer<T> openUpdate() {
        return UpdateChainer.of(getBaseMapper());
    }

    default DeleteChainer<T> openDelete() {
        return DeleteChainer.of(getBaseMapper());
    }

    /**
     * insert and not append the null column value.
     * <ul>
     *   <li>if the value of primary key is null or blank string, will be generated by primary key generate strategy.</li>
     *   <li>if the value of primary key is not null or not blank string, then using the primary key value in entity.</li>
     *   <li>supported the entity with multiple primary keys.</li>
     * </ul>
     * for example:
     * <ul>
     *   <li>
     *       the entity: TestTablePO(id=null, name="testName")<br/>
     *       the generated sql: INSERT INTO "test_table"("id", "name") VALUES (487223443892741, 'testName');
     *   </li>
     *   <br/>
     *   <li>
     *       the entity: TestTablePO(id=null, name=null)<br/>
     *       the generated sql: INSERT INTO "test_table"("id") VALUES (487223443892741);
     *   </li>
     *   <br/>
     *   <li>
     *       the entity: TestTablePO(id=1, name=null)<br/>
     *       the generated sql: INSERT INTO "test_table"("id") VALUES (1);
     *   </li>
     *   <br/>
     *   <li>
     *       the entity with two primary keys: TestTablePO(id1=null, id2=null).<br/>
     *       the generated sql: INSERT INTO "test_table"("id1", "id2") VALUES (487223443892741, 487223443892742);
     *   </li>
     *   <br/>
     *   <li>
     *       the entity with two primary keys: TestTablePO(id1=1L, id2=2L).<br/>
     *       the generated sql: INSERT INTO "test_table"("id1", "id2") VALUES (1, 2);
     *   </li>
     * </ul>
     *
     * @param entity the operate entity
     * @return the entity with primary key
     * @see BaseMapper#insertSelective(Object)
     * @see CustomKeyGenerator#processBefore(Executor, MappedStatement, Statement, Object)
     */
    default T save(T entity) {
        getBaseMapper().insertSelective(entity);
        return entity;
    }

    /**
     * using {@link #GENERATE_FULL_SQL_BATCH_SIZE batch size each time} to insert batch.
     *
     * @param entities the operate entities
     * @return the entities with primary key
     * @see #GENERATE_FULL_SQL_BATCH_SIZE
     * @see #save(PO)
     * @see #save(Iterable, int)
     * @see BaseMapper#insertSelective(Object)
     * @see BaseMapper#insertBatch(List, int)
     * @see IService#saveBatch(Collection, int)
     * @see CustomKeyGenerator#processBefore(Executor, MappedStatement, Statement, Object)
     */
    default List<T> save(Iterable<T> entities) {
        return save(entities, DEFAULT_BATCH_SIZE_EACH_TIME);
    }

    /**
     * insert batch.
     * <ol>
     *   <li>
     *       using {@link BaseMapper#insertBatch(List, int)} if the entites size <= {@link #GENERATE_FULL_SQL_BATCH_SIZE}, the generated insert sql like:<br/>
     *       <br/>
     *       INSERT INTO "test_table"("id", "name") VALUES<br/>
     *       (487223443892741, 'test1'),<br/>
     *       (487223443892742, 'test2'),<br/>
     *       (487223443913230, 'test3');
     *   </li>
     *   <br/>
     *   <li>
     *       using {@link IService#saveBatch(Collection, int)} if the entites size > {@link #GENERATE_FULL_SQL_BATCH_SIZE}, the generated insert sql like:<br/>
     *       <br/>
     *       INSERT INTO "test_table"("id", "name") VALUES (487223443892741, 'test1');<br/>
     *       INSERT INTO "test_table"("id", "name") VALUES (487223443892742, 'test2');<br/>
     *       INSERT INTO "test_table"("id", "name") VALUES (487223443913230, 'test3');
     *   </li>
     * </ol>
     *
     * @param entities          the operate entities
     * @param batchSizeEachTime insert size each time
     * @return the entities with primary key
     * @apiNote about the different between {@link BaseMapper#insertBatch(List, int)} and {@link IService#saveBatch(Collection, int)}, you should see <a href="https://mybatis-flex.com/zh/base/batch.html">"the batch operation guide"</a>.
     * @see #GENERATE_FULL_SQL_BATCH_SIZE
     * @see #save(PO)
     * @see BaseMapper#insertSelective(Object)
     * @see BaseMapper#insertBatch(List, int)
     * @see IService#saveBatch(Collection, int)
     * @see CustomKeyGenerator#processBefore(Executor, MappedStatement, Statement, Object)
     */
    @Transactional(rollbackFor = Throwable.class)
    default List<T> save(Iterable<T> entities, int batchSizeEachTime) {
        if (Nil.isEmpty(entities)) {
            return Collections.newArrayList();
        }
        List<T> listTypeEntities = entities instanceof List<T> ? (List<T>) entities : Converts.toList(entities);
        Action.ifTrue(listTypeEntities.size() <= GENERATE_FULL_SQL_BATCH_SIZE)
                .then(() -> getBaseMapper().insertBatch(listTypeEntities, batchSizeEachTime))
                .otherwise(() -> Db.executeBatch(listTypeEntities, batchSizeEachTime, ClassUtil.getUsefulClass(this.getClass()), GenericCurdDao::save));
        return listTypeEntities;
    }

    /**
     * update by id.
     *
     * @param entity â€“ the operate entity
     * @see #updateById(Iterable, int)
     */
    default void updateById(T entity) {
        getBaseMapper().update(entity);
    }

    /**
     * update batch by id.
     *
     * @param entities the operate entities
     * @see #updateById(Iterable, int)
     * @see IService#updateBatch(Collection, int)
     */
    default void updateById(T... entities) {
        updateById(Collections.ofArrayList(entities));
    }

    /**
     * using {@link #GENERATE_FULL_SQL_BATCH_SIZE batch size each time} to update by id.
     *
     * @param entities the operate entities
     * @see #updateById(Iterable, int)
     * @see IService#updateBatch(Collection, int)
     */
    default void updateById(Iterable<T> entities) {
        updateById(entities, DEFAULT_BATCH_SIZE_EACH_TIME);
    }

    /**
     * update batch by id.
     * <ul>
     *   <li>using {@link IService#updateBatch(Collection, int)} to update.</li>
     *   <li>supported the entity with multiple primary keys.</li>
     * </ul>
     * <ul>
     *   <li>for example:</li>
     *   <ul>
     *     <li>
     *         if the entity has one primary key, the generated insert sql like:<br/><br/>
     *         UPDATE "test_table" SET "name" = 'test1' WHERE "id" = 1;
     *     </li>
     *     <br/>
     *     <li>
     *         if the entity has two primary keys, the generated insert sql like:<br/><br/>
     *         UPDATE "test_table" SET "name" = 'test1' WHERE "id" = 1 AND "id2" = 2;
     *     </li>
     *   </ul>
     * </ul>
     *
     * @param entities          the operate entities
     * @param batchSizeEachTime insert size each time
     * @apiNote see <a href="https://mybatis-flex.com/zh/base/batch.html">"the batch operation guide"</a>.
     * @see IService#updateBatch(Collection, int)
     */
    @Transactional(rollbackFor = Throwable.class)
    default void updateById(Iterable<T> entities, int batchSizeEachTime) {
        Db.executeBatch(
                entities instanceof Collection<T> ? (Collection<T>) entities : Converts.toList(entities),
                batchSizeEachTime,
                ClassUtil.getUsefulClass(this.getClass()),
                GenericCurdDao::updateById
        );
    }

    /**
     * update by id.
     * <ul>
     *   <li>supported the entity with version.</li>
     *   <li>supported the entity with multiple primary keys.</li><br/>
     *   <li>the update stage as following:</li>
     *   <ul>
     *     <li>the entity with one primary key: TestTablePO(id=1L, name="test1", version=0).</li>
     *     <ol>
     *       <li>SELECT * FROM "test_table" WHERE "id" = 1;</li>
     *       <li>UPDATE "test_table" SET "name" = 'test2', "version" = "version" + 1  WHERE "id" = 1 AND "version" = 0;</li>
     *     </ol>
     *   </ul>
     *   <ul>
     *     <li>the entity with two primary key: TestTablePO(id1=1L, id2=2L, name="test1", version=0).</li>
     *     <ol>
     *       <li>SELECT * FROM "test_table" WHERE "id" = 1 AND "id2" = 2;</li>
     *       <li>UPDATE "test_table" SET "name" = 'test2', "version" = "version" + 1  WHERE "id" = 1 AND "id2" = 2 AND "version" = 0;</li>
     *     </ol>
     *   </ul>
     * </ul>
     *
     * @param entity the operate entitiy
     * @see #updateById(PO)
     */
    default void updateWithVersionById(T entity) {
        setVersionFieldValue(getEntityToUpdateVersion(entity), entity);
        updateById(entity);
    }

    /**
     * update batch by id.
     *
     * @param entities    the operate entities
     * @param getIdAction how to find the primary key in each entity
     * @apiNote only support the entity with one primary key.
     * @see #updateWithVersionById(Iterable, int, Function)
     * @see #updateById(Iterable, int)
     * @see IService#updateBatch(Collection, int)
     */
    default void updateWithVersionById(Iterable<T> entities, Function<T, ? extends Serializable> getIdAction) {
        setVersionFieldValues(entities, getIdAction);
        updateById(entities);
    }

    /**
     * update batch by id.
     * <ul>
     *   <li>supported the entity with version.</li>
     *   <li>only support the entity with one primary key.</li><br/>
     *   <li>the update stage as following:</li>
     *   <ul>
     *     <li>the entities with one primary key: [TestTablePO(id=1L, name="test1", version=0), TestTablePO(id=2L, name="test2", version=0)].</li>
     *     <ol>
     *       <li>SELECT * FROM "test_table" WHERE "id" = 1  OR "id" = 2;</li>
     *       <li>UPDATE "test_table" SET "name" = 'test3', "version" = "version" + 1  WHERE "id" = 1 AND "version" = 0;</li>
     *       <li>UPDATE "test_table" SET "name" = 'test4', "version" = "version" + 1  WHERE "id" = 2 AND "version" = 0;</li>
     *     </ol>
     *   </ul>
     * </ul>
     *
     * @param entities          the operate entities
     * @param batchSizeEachTime insert size each time
     * @param getIdAction       how to find the primary key in each entity
     * @apiNote only support the entity with one primary key.
     * @see #updateById(Iterable, int)
     * @see IService#updateBatch(Collection, int)
     */
    default void updateWithVersionById(Iterable<T> entities, int batchSizeEachTime, Function<T, ? extends Serializable> getIdAction) {
        setVersionFieldValues(entities, getIdAction);
        updateById(entities, batchSizeEachTime);
    }

    /**
     * delete by id, recommended for the entity with multiple primary keys.
     * <ol>
     *   <li>
     *       if the entity has the logic delete column:<br/>
     *       <ul>
     *         <li>
     *              the entity with two primary keys: TestTablePO(id1=1L, id2=2L, rowIsDeleted=null).
     *         </li>
     *         <li>
     *              the generated delete sql like:<br/><br/>
     *              UPDATE "test_table"<br/>
     *              SET "row_is_deleted" = TRUE<br/>
     *              WHERE "id1" = 1 AND "id2" = 2 AND "row_is_deleted" = FALSE;
     *         </li>
     *       </ul>
     *   </li>
     *   <br/>
     *   <li>
     *       if the entity does not have the logic delete column:<br/>
     *       <ul>
     *         <li>
     *              the entity with two primary keys: TestTablePO(id1=1L, id2=2L).
     *         </li>
     *         <li>
     *              the generated delete sql like:<br/><br/>
     *              DELETE<br/>
     *              FROM "test_table"<br/>
     *              WHERE "id1" = 1 AND "id2" = 2 AND "row_is_deleted" = FALSE;
     *         </li>
     *       </ul>
     *   </li>
     * </ol>
     *
     * @param entity the entity
     */
    default void deleteById(T entity) {
        getBaseMapper().delete(entity);
    }

    /**
     * delete batch by ids.
     *
     * @param ids the primary key values
     * @see #deleteByIds(Iterable)
     */
    default void deleteByIds(Serializable... ids) {
        deleteByIds(Collections.ofHashSet(ids));
    }

    /**
     * delete batch by ids.
     * <ol>
     *   <li>
     *       if the entity has the logic delete column, the generated delete sql like:<br/>
     *       <br/>
     *       UPDATE "test_table"<br/>
     *       SET "row_is_deleted" = TRUE<br/>
     *       WHERE ("id" = 1 OR "id" = 2 OR "id" = 3)<br/>
     *       AND "row_is_deleted" = FALSE;
     *   </li>
     *   <br/>
     *   <li>
     *       if the entity does not have the logic delete column, the generated delete sql like:<br/>
     *       <br/>
     *       DELETE<br/>
     *       FROM "test_table"<br/>
     *       WHERE "id" = 1 OR "id" = 2 OR "id" = 3;
     *   </li>
     * </ol>
     *
     * @param ids the primary key values
     */
    default void deleteByIds(Iterable<? extends Serializable> ids) {
        getBaseMapper().deleteBatchByIds(ids instanceof Collection<? extends Serializable> ? (Collection<? extends Serializable>) ids : Converts.toSet(ids));
    }

    /**
     * delete skip logic anyway, recommended for the entity with multiple primary keys.
     * <ul>
     *   <li>
     *       no matter of whether the entity has the logic delete column:<br/>
     *       <ul>
     *         <li>
     *              the entity with two primary keys: TestTablePO(id1=1L, id2=2L, rowIsDeleted=null).
     *         </li>
     *         <li>
     *              the generated delete sql like:<br/><br/>
     *              DELETE<br/>
     *              FROM "test_table"<br/>
     *              WHERE "id1" = 1 AND "id2" = 2 AND "row_is_deleted" = FALSE;
     *         </li>
     *       </ul>
     *   </li>
     * </ul>
     *
     * @param entity the entity
     */
    default void deleteSkipLogicById(T entity) {
        LogicDeleteManager.execWithoutLogicDelete(() -> deleteById(entity));
    }

    /**
     * delete skip logic anyway.
     *
     * @param id the primary key value
     * @see #deleteSkipLogicByIds(Iterable)
     */
    default void deleteSkipLogicById(Serializable id) {
        LogicDeleteManager.execWithoutLogicDelete(() -> deleteById(id));
    }

    /**
     * delete batch skip logic anyway.
     *
     * @param ids the primary key values
     * @see #deleteSkipLogicByIds(Iterable)
     */
    default void deleteSkipLogicByIds(Serializable... ids) {
        deleteSkipLogicByIds(Collections.ofHashSet(ids));
    }

    /**
     * delete batch skip logic anyway.
     * <ul>
     *   <li>
     *       no matter of whether the entity has the logic delete column, the generated delete sql like:<br/>
     *       <br/>
     *       DELETE<br/>
     *       FROM "test_table"<br/>
     *       WHERE "id" = 1 OR "id" = 2 OR "id" = 3;
     *   </li>
     * </ul>
     *
     * @param ids the primary key values
     */
    default void deleteSkipLogicByIds(Iterable<? extends Serializable> ids) {
        LogicDeleteManager.execWithoutLogicDelete(() -> deleteByIds(ids instanceof Collection<? extends Serializable> ? (Collection<? extends Serializable>) ids : Converts.toSet(ids)));
    }

    // default T getById(T entity) {
    default Optional<T> getById(T entity) {
        return Optional.ofNullable(GenericCurdDaoAdapter.getInstance().getBaseMapper(this.getClass()).selectOneByEntityId(entity));
    }

    default Optional<T> getById(Serializable id) {
        return Optional.ofNullable(getBaseMapper().selectOneById(id));
    }

    default Optional<T> getByCondition(QueryWrapper queryWrapper) {
        return Optional.ofNullable(getBaseMapper().selectOneByQuery(queryWrapper));
    }

    default List<T> listByIds(Iterable<? extends Serializable> ids) {
        return getBaseMapper().selectListByIds(ids instanceof Collection<? extends Serializable> ? (Collection<? extends Serializable>) ids : Converts.toSet(ids));
    }

    default List<T> listByCondition(QueryWrapper queryWrapper) {
        return getBaseMapper().selectListByQuery(queryWrapper);
    }

    default List<T> listAll() {
        return listByCondition(QueryWrapper.create());
    }

    default <R extends BO> List<R> listByCondition(QueryWrapper queryWrapper, Class<R> asType) {
        return getBaseMapper().selectListByQueryAs(queryWrapper, asType);
    }

    default PageResult<T> pageByCondition(QueryWrapper queryWrapper) {
        return pageByCondition(PageConstant.DEFAULT_PAGE_INDEX, PageConstant.DEFAULT_PAGE_SIZE, queryWrapper);
    }

    default PageResult<T> pageByCondition(PageParam pageParam, QueryWrapper queryWrapper) {
        return pageByCondition(pageParam.getPageIndex(), pageParam.getPageSize(), queryWrapper);
    }

    default PageResult<T> pageByCondition(Number pageIndex, Number pageSize, QueryWrapper queryWrapper) {
        return PageConverter.INSTANCE.toPageResult(getBaseMapper().paginate(pageIndex, pageSize, queryWrapper));
    }

    default long countByCondition(QueryWrapper queryWrapper) {
        return getBaseMapper().selectCountByQuery(queryWrapper);
    }

    default long countAll() {
        return countByCondition(QueryWrapper.create());
    }

    private T getEntityToUpdateVersion(T updatedEntity) {
        return getById(updatedEntity).orElseThrow(() -> new LibraryJavaInternalException(Strings.format("{}update with version failed, the entity [{}] could not be found any data in table [{}], please check!", ModuleView.ORM_MYBATIS_SYSTEM, updatedEntity.getClass().getName(), MybatisFlexs.getTableName(updatedEntity).orElse(null))));
    }

    private void setVersionFieldValue(T oldEntity, T updatedEntity) {
        String versionFieldName = MybatisFlexs.getVersionFieldName(updatedEntity).orElseThrow(() -> new LibraryJavaInternalException(Strings.format("{}update with version failed, the entity [{}] does not have the version column, please check!", ModuleView.ORM_MYBATIS_SYSTEM, updatedEntity.getClass().getName())));
        Reflects.setFieldValue(updatedEntity, versionFieldName, Reflects.getFieldValue(oldEntity, versionFieldName));
    }

    private void setVersionFieldValues(Iterable<T> updatedEntities, Function<T, ? extends Serializable> getIdAction) {
        Map<? extends Serializable, T> idMappingOldEntity = Converts.toMap(listByIds(Converts.toList(updatedEntities, getIdAction)), getIdAction);
        Map<? extends Serializable, T> idMappingUpdatedEntity = Converts.toMap(updatedEntities, getIdAction);
        idMappingOldEntity.forEach((id, oldEntity) -> {
            setVersionFieldValue(oldEntity, idMappingUpdatedEntity.get(id));
        });
    }

}